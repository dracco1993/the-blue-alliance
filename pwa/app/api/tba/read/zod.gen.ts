// This file is auto-generated by @hey-api/openapi-ts
import * as z from 'zod';

export const zApiStatusAppVersion = z.object({
  min_app_version: z.int(),
  latest_app_version: z.int(),
});

export const zApiStatus = z.object({
  current_season: z.int(),
  max_season: z.int(),
  is_datafeed_down: z.boolean(),
  down_events: z.array(z.string()),
  ios: zApiStatusAppVersion,
  android: zApiStatusAppVersion,
  max_team_page: z.int(),
});

export const zAutoChargeStationRobot2023 = z.enum(['Docked', 'None']);

export const zAutoLineRobot2024 = z.enum(['No', 'Yes']);

export const zAutoRobot2018 = z.enum(['None', 'AutoRun']);

/**
 * An `Award_Recipient` object represents the team and/or person who received an award at an event.
 */
export const zAwardRecipient = z.object({
  team_key: z.string().nullable(),
  awardee: z.string().nullable(),
});

export const zAward = z.object({
  name: z.string(),
  award_type: z.int(),
  event_key: z.string(),
  recipient_list: z.array(zAwardRecipient),
  year: z.int(),
});

export const zBay2019 = z.enum(['None', 'Panel', 'PanelAndCargo']);

export const zBridgeState2023 = z.enum(['Level', 'NotLevel']);

/**
 * The competition level the match was played at.
 */
export const zCompLevel = z.enum(['qm', 'ef', 'qf', 'sf', 'f']);

export const zDistrict = z.object({
  abbreviation: z.string(),
  display_name: z.string(),
  key: z.string(),
  year: z.int(),
});

export const zDistrictInsightRegionData = z.object({
  yearly_active_team_count: z.record(z.string(), z.int()),
  yearly_event_count: z.record(z.string(), z.int()),
  yearly_gained_teams: z.record(z.string(), z.array(z.string())),
  yearly_lost_teams: z.record(z.string(), z.array(z.string())),
});

/**
 * Advancement status of a team in a district.
 */
export const zDistrictAdvancement = z.object({
  dcmp: z.boolean(),
  cmp: z.boolean(),
});

/**
 * Rank of a team in a district.
 */
export const zDistrictRanking = z.object({
  team_key: z.string(),
  rank: z.int(),
  rookie_bonus: z.int(),
  point_total: z.int(),
  event_points: z.array(
    z.object({
      district_cmp: z.boolean(),
      total: z.int(),
      alliance_points: z.int(),
      elim_points: z.int(),
      award_points: z.int(),
      event_key: z.string(),
      qual_points: z.int(),
    }),
  ),
  adjustments: z.int().optional(),
  other_bonus: z.int().optional(),
});

/**
 * Double elimination round, if applicable.
 */
export const zDoubleElimRound = z.enum([
  'Finals',
  'Round 1',
  'Round 2',
  'Round 3',
  'Round 4',
  'Round 5',
]);

export const zEndGameChargeStationRobot2023 = z.enum([
  'Docked',
  'None',
  'Park',
  'Parked',
]);

export const zEndGameRobot2024 = z.enum([
  'CenterStage',
  'None',
  'Parked',
  'StageLeft',
  'StageRight',
]);

export const zEndGameRobot2025 = z.enum([
  'DeepCage',
  'None',
  'Parked',
  'ShallowCage',
]);

export const zTowerRobot2026 = z.enum(['Level1', 'Level2', 'Level3', 'None']);

export const zHubScore2026 = z.object({
  autoCount: z.int(),
  autoPoints: z.int(),
  endgameCount: z.int(),
  endgamePoints: z.int(),
  shift1Count: z.int(),
  shift1Points: z.int(),
  shift2Count: z.int(),
  shift2Points: z.int(),
  shift3Count: z.int(),
  shift3Points: z.int(),
  shift4Count: z.int(),
  shift4Points: z.int(),
  teleopCount: z.int(),
  teleopPoints: z.int(),
  totalCount: z.int(),
  totalPoints: z.int(),
  transitionCount: z.int(),
  transitionPoints: z.int(),
});

export const zEndgameRobot2018 = z.enum([
  'Climbing',
  'Levitate',
  'None',
  'Parking',
  'Unknown',
]);

export const zEndgameRobot2019 = z.enum([
  'HabLevel1',
  'HabLevel2',
  'HabLevel3',
  'None',
  'Unknown',
]);

export const zEndgameRobot2020 = z.enum(['Hang', 'None', 'Park']);

export const zEndgameRobot2022 = z.enum([
  'High',
  'Low',
  'Mid',
  'None',
  'Traversal',
]);

export const zEndgameRungIsLevel2020 = z.enum(['IsLevel', 'NotLevel']);

/**
 * Component OPRs for teams at the event.
 */
export const zEventCoprs = z.record(
  z.string(),
  z.record(z.string(), z.number()),
);

export const zEventDistrictPoints = z.object({
  points: z.record(
    z.string(),
    z.object({
      total: z.int(),
      alliance_points: z.int(),
      elim_points: z.int(),
      award_points: z.int(),
      qual_points: z.int(),
    }),
  ),
  tiebreakers: z
    .record(
      z.string(),
      z.object({
        highest_qual_scores: z.array(z.int()).optional(),
        qual_wins: z.int().optional(),
      }),
    )
    .optional(),
});

/**
 * A year-specific event insight object expressed as a JSON string, separated in to `qual` and `playoff` fields. See also Event_Insights_2016, Event_Insights_2017, etc.
 */
export const zEventInsights = z.object({
  qual: z.record(z.string(), z.unknown()).optional(),
  playoff: z.record(z.string(), z.unknown()).optional(),
});

/**
 * Insights for FIRST Stronghold qualification and elimination matches.
 */
export const zEventInsights2016 = z.object({
  LowBar: z.array(z.number()),
  A_ChevalDeFrise: z.array(z.number()),
  A_Portcullis: z.array(z.number()),
  B_Ramparts: z.array(z.number()),
  B_Moat: z.array(z.number()),
  C_SallyPort: z.array(z.number()),
  C_Drawbridge: z.array(z.number()),
  D_RoughTerrain: z.array(z.number()),
  D_RockWall: z.array(z.number()),
  average_high_goals: z.number(),
  average_low_goals: z.number(),
  breaches: z.array(z.number()),
  scales: z.array(z.number()),
  challenges: z.array(z.number()),
  captures: z.array(z.number()),
  average_win_score: z.number(),
  average_win_margin: z.number(),
  average_score: z.number(),
  average_auto_score: z.number(),
  average_crossing_score: z.number(),
  average_boulder_score: z.number(),
  average_tower_score: z.number(),
  average_foul_score: z.number(),
  high_score: z.array(z.string()),
});

/**
 * Insights for FIRST STEAMWORKS qualification and elimination matches.
 */
export const zEventInsights2017 = z.object({
  average_foul_score: z.number(),
  average_fuel_points: z.number(),
  average_fuel_points_auto: z.number(),
  average_fuel_points_teleop: z.number(),
  average_high_goals: z.number(),
  average_high_goals_auto: z.number(),
  average_high_goals_teleop: z.number(),
  average_low_goals: z.number(),
  average_low_goals_auto: z.number(),
  average_low_goals_teleop: z.number(),
  average_mobility_points_auto: z.number(),
  average_points_auto: z.number(),
  average_points_teleop: z.number(),
  average_rotor_points: z.number(),
  average_rotor_points_auto: z.number(),
  average_rotor_points_teleop: z.number(),
  average_score: z.number(),
  average_takeoff_points_teleop: z.number(),
  average_win_margin: z.number(),
  average_win_score: z.number(),
  high_kpa: z.array(z.string()),
  high_score: z.array(z.string()),
  kpa_achieved: z.array(z.number()),
  mobility_counts: z.array(z.number()),
  rotor_1_engaged: z.array(z.number()),
  rotor_1_engaged_auto: z.array(z.number()),
  rotor_2_engaged: z.array(z.number()),
  rotor_2_engaged_auto: z.array(z.number()),
  rotor_3_engaged: z.array(z.number()),
  rotor_4_engaged: z.array(z.number()),
  takeoff_counts: z.array(z.number()),
  unicorn_matches: z.array(z.number()),
});

/**
 * Insights for FIRST Power Up qualification and elimination matches.
 */
export const zEventInsights2018 = z.object({
  auto_quest_achieved: z.array(z.number()),
  average_boost_played: z.number(),
  average_endgame_points: z.number(),
  average_force_played: z.number(),
  average_foul_score: z.number(),
  average_points_auto: z.number(),
  average_points_teleop: z.number(),
  average_run_points_auto: z.number(),
  average_scale_ownership_points: z.number(),
  average_scale_ownership_points_auto: z.number(),
  average_scale_ownership_points_teleop: z.number(),
  average_score: z.number(),
  average_switch_ownership_points: z.number(),
  average_switch_ownership_points_auto: z.number(),
  average_switch_ownership_points_teleop: z.number(),
  average_vault_points: z.number(),
  average_win_margin: z.number(),
  average_win_score: z.number(),
  boost_played_counts: z.array(z.number()),
  climb_counts: z.array(z.number()),
  face_the_boss_achieved: z.array(z.number()),
  force_played_counts: z.array(z.number()),
  high_score: z.array(z.string()),
  levitate_played_counts: z.array(z.number()),
  run_counts_auto: z.array(z.number()),
  scale_neutral_percentage: z.number(),
  scale_neutral_percentage_auto: z.number(),
  scale_neutral_percentage_teleop: z.number(),
  switch_owned_counts_auto: z.array(z.number()),
  unicorn_matches: z.array(z.number()),
  winning_opp_switch_denial_percentage_teleop: z.number(),
  winning_own_switch_ownership_percentage: z.number(),
  winning_own_switch_ownership_percentage_auto: z.number(),
  winning_own_switch_ownership_percentage_teleop: z.number(),
  winning_scale_ownership_percentage: z.number(),
  winning_scale_ownership_percentage_auto: z.number(),
  winning_scale_ownership_percentage_teleop: z.number(),
});

/**
 * OPR, DPR, and CCWM for teams at the event.
 */
export const zEventOprs = z.object({
  oprs: z.record(z.string(), z.number()).optional(),
  dprs: z.record(z.string(), z.number()).optional(),
  ccwms: z.record(z.string(), z.number()).optional(),
});

/**
 * JSON Object containing prediction information for the event. Contains year-specific information and is subject to change.
 */
export const zEventPredictions = z.record(z.string(), z.unknown());

export const zEventSimple = z.object({
  key: z.string(),
  name: z.string(),
  event_code: z.string(),
  event_type: z.int(),
  district: zDistrict.nullable(),
  city: z.string().nullable(),
  state_prov: z.string().nullable(),
  country: z.string().nullable(),
  start_date: z.iso.date(),
  end_date: z.iso.date(),
  year: z.int(),
});

export const zHabLine2019 = z.enum([
  'CrossedHabLineInSandstorm',
  'CrossedHabLineInTeleop',
  'None',
  'Unknown',
]);

export const zInitLineRobot2020 = z.enum(['Exited', 'None']);

export const zLeaderboardInsight = z.object({
  data: z.object({
    rankings: z.array(
      z.object({
        value: z.number(),
        keys: z.array(z.string()),
      }),
    ),
    key_type: z.enum(['team', 'event', 'match']),
  }),
  name: z.string(),
  year: z.int(),
});

export const zMatchScoreBreakdown2015Alliance = z.object({
  auto: z.string().nullish(),
  auto_points: z.int().nullish(),
  teleop_points: z.int().optional(),
  container_points: z.int().optional(),
  tote_points: z.int().optional(),
  litter_points: z.int().optional(),
  foul: z.string().nullish(),
  foul_points: z.int().nullish(),
  adjust_points: z.int().optional(),
  total_points: z.int().optional(),
  foul_count: z.int().optional(),
  tote_count_far: z.int().optional(),
  tote_count_near: z.int().optional(),
  tote_set: z.boolean().optional(),
  tote_stack: z.boolean().optional(),
  container_count_level1: z.int().optional(),
  container_count_level2: z.int().optional(),
  container_count_level3: z.int().optional(),
  container_count_level4: z.int().optional(),
  container_count_level5: z.int().optional(),
  container_count_level6: z.int().optional(),
  container_set: z.boolean().optional(),
  litter_count_container: z.int().optional(),
  litter_count_landfill: z.int().optional(),
  litter_count_unprocessed: z.int().optional(),
  robot_set: z.boolean().optional(),
});

/**
 * See the 2015 FMS API documentation for a description of each value
 */
export const zMatchScoreBreakdown2015 = z.object({
  blue: zMatchScoreBreakdown2015Alliance,
  red: zMatchScoreBreakdown2015Alliance,
  coopertition: z.enum(['None', 'Unknown', 'Stack']),
  coopertition_points: z.int(),
});

export const zMatchScoreBreakdown2018Alliance = z.object({
  adjustPoints: z.int().optional(),
  autoOwnershipPoints: z.int(),
  autoPoints: z.int(),
  autoQuestRankingPoint: z.boolean().optional(),
  autoRobot1: zAutoRobot2018.optional(),
  autoRobot2: zAutoRobot2018.optional(),
  autoRobot3: zAutoRobot2018.optional(),
  autoRunPoints: z.int(),
  autoScaleOwnershipSec: z.int(),
  autoSwitchAtZero: z.boolean().optional(),
  autoSwitchOwnershipSec: z.int(),
  endgamePoints: z.int(),
  endgameRobot1: zEndgameRobot2018.optional(),
  endgameRobot2: zEndgameRobot2018.optional(),
  endgameRobot3: zEndgameRobot2018.optional(),
  faceTheBossRankingPoint: z.boolean(),
  foulCount: z.int().optional(),
  foulPoints: z.int(),
  rp: z.int(),
  techFoulCount: z.int().optional(),
  teleopOwnershipPoints: z.int(),
  teleopPoints: z.int(),
  teleopScaleBoostSec: z.int(),
  teleopScaleForceSec: z.int().optional(),
  teleopScaleOwnershipSec: z.int(),
  teleopSwitchBoostSec: z.int(),
  teleopSwitchForceSec: z.int().optional(),
  teleopSwitchOwnershipSec: z.int(),
  totalPoints: z.int(),
  vaultBoostPlayed: z.int(),
  vaultBoostTotal: z.int(),
  vaultForcePlayed: z.int(),
  vaultForceTotal: z.int(),
  vaultLevitatePlayed: z.int(),
  vaultLevitateTotal: z.int(),
  vaultPoints: z.int(),
  tba_gameData: z.enum(['', 'LLL', 'LRL', 'RLR', 'RRR']).optional(),
});

/**
 * See the 2018 FMS API documentation for a description of each value. https://frcevents2.docs.apiary.io/#/reference/match-results/score-details
 */
export const zMatchScoreBreakdown2018 = z.object({
  blue: zMatchScoreBreakdown2018Alliance,
  red: zMatchScoreBreakdown2018Alliance,
});

export const zMatchScoreBreakdown2024Alliance = z.object({
  adjustPoints: z.int().optional(),
  autoAmpNoteCount: z.int().optional(),
  autoAmpNotePoints: z.int().optional(),
  autoLeavePoints: z.int().optional(),
  autoLineRobot1: zAutoLineRobot2024.optional(),
  autoLineRobot2: zAutoLineRobot2024.optional(),
  autoLineRobot3: zAutoLineRobot2024.optional(),
  autoPoints: z.int().optional(),
  autoSpeakerNoteCount: z.int().optional(),
  autoSpeakerNotePoints: z.int().optional(),
  autoTotalNotePoints: z.int().optional(),
  coopNotePlayed: z.boolean().optional(),
  coopertitionBonusAchieved: z.boolean().optional(),
  coopertitionCriteriaMet: z.boolean().optional(),
  endGameHarmonyPoints: z.int().optional(),
  endGameNoteInTrapPoints: z.int().optional(),
  endGameOnStagePoints: z.int().optional(),
  endGameParkPoints: z.int().optional(),
  endGameRobot1: zEndGameRobot2024.optional(),
  endGameRobot2: zEndGameRobot2024.optional(),
  endGameRobot3: zEndGameRobot2024.optional(),
  endGameSpotLightBonusPoints: z.int().optional(),
  endGameTotalStagePoints: z.int().optional(),
  ensembleBonusAchieved: z.boolean().optional(),
  ensembleBonusOnStageRobotsThreshold: z.int().optional(),
  ensembleBonusStagePointsThreshold: z.int().optional(),
  foulCount: z.int().optional(),
  foulPoints: z.int().optional(),
  g206Penalty: z.boolean().optional(),
  g408Penalty: z.boolean().optional(),
  g424Penalty: z.boolean().optional(),
  melodyBonusAchieved: z.boolean().optional(),
  melodyBonusThreshold: z.int().optional(),
  melodyBonusThresholdCoop: z.int().optional(),
  melodyBonusThresholdNonCoop: z.int().optional(),
  micCenterStage: z.boolean().optional(),
  micStageLeft: z.boolean().optional(),
  micStageRight: z.boolean().optional(),
  rp: z.int(),
  techFoulCount: z.int().optional(),
  teleopAmpNoteCount: z.int().optional(),
  teleopAmpNotePoints: z.int().optional(),
  teleopPoints: z.int().optional(),
  teleopSpeakerNoteAmplifiedCount: z.int().optional(),
  teleopSpeakerNoteAmplifiedPoints: z.int().optional(),
  teleopSpeakerNoteCount: z.int().optional(),
  teleopSpeakerNotePoints: z.int().optional(),
  teleopTotalNotePoints: z.int().optional(),
  totalPoints: z.int(),
  trapCenterStage: z.boolean().optional(),
  trapStageLeft: z.boolean().optional(),
  trapStageRight: z.boolean().optional(),
});

/**
 * See the 2024 FMS API documentation for a description of each value. https://frc-api-docs.firstinspires.org
 */
export const zMatchScoreBreakdown2024 = z.object({
  blue: zMatchScoreBreakdown2024Alliance,
  red: zMatchScoreBreakdown2024Alliance,
});

export const zMatchScoreBreakdown2026Alliance = z.object({
  adjustPoints: z.int(),
  autoTowerPoints: z.int(),
  autoTowerRobot1: zTowerRobot2026,
  autoTowerRobot2: zTowerRobot2026,
  autoTowerRobot3: zTowerRobot2026,
  endGameTowerPoints: z.int(),
  endGameTowerRobot1: zTowerRobot2026,
  endGameTowerRobot2: zTowerRobot2026,
  endGameTowerRobot3: zTowerRobot2026,
  energizedAchieved: z.boolean(),
  foulPoints: z.int(),
  g206Penalty: z.boolean(),
  hubScore: zHubScore2026,
  majorFoulCount: z.int(),
  minorFoulCount: z.int(),
  rp: z.int(),
  superchargedAchieved: z.boolean(),
  totalAutoPoints: z.int(),
  totalPoints: z.int(),
  totalTeleopPoints: z.int(),
  totalTowerPoints: z.int(),
  traversalAchieved: z.boolean(),
});

/**
 * See the 2026 FMS API documentation for a description of each value. https://frc-api-docs.firstinspires.org
 */
export const zMatchScoreBreakdown2026 = z.object({
  blue: zMatchScoreBreakdown2026Alliance,
  red: zMatchScoreBreakdown2026Alliance,
});

/**
 * Timeseries data for the 2018 game *FIRST* POWER UP.
 * *WARNING:* This is *not* official data, and is subject to a significant possibility of error, or missing data. Do not rely on this data for any purpose. In fact, pretend we made it up.
 * *WARNING:* This model is currently under active development and may change at any time, including in breaking ways.
 */
export const zMatchTimeseries2018 = z.object({
  event_key: z.string().optional(),
  match_id: z.string().optional(),
  mode: z.string().optional(),
  play: z.int().optional(),
  time_remaining: z.int().optional(),
  blue_auto_quest: z.int().optional(),
  blue_boost_count: z.int().optional(),
  blue_boost_played: z.int().optional(),
  blue_current_powerup: z.string().optional(),
  blue_face_the_boss: z.int().optional(),
  blue_force_count: z.int().optional(),
  blue_force_played: z.int().optional(),
  blue_levitate_count: z.int().optional(),
  blue_levitate_played: z.int().optional(),
  blue_powerup_time_remaining: z.string().optional(),
  blue_scale_owned: z.int().optional(),
  blue_score: z.int().optional(),
  blue_switch_owned: z.int().optional(),
  red_auto_quest: z.int().optional(),
  red_boost_count: z.int().optional(),
  red_boost_played: z.int().optional(),
  red_current_powerup: z.string().optional(),
  red_face_the_boss: z.int().optional(),
  red_force_count: z.int().optional(),
  red_force_played: z.int().optional(),
  red_levitate_count: z.int().optional(),
  red_levitate_played: z.int().optional(),
  red_powerup_time_remaining: z.string().optional(),
  red_scale_owned: z.int().optional(),
  red_score: z.int().optional(),
  red_switch_owned: z.int().optional(),
});

export const zMatchAlliance = z.object({
  score: z.int(),
  team_keys: z.array(z.string()),
  surrogate_team_keys: z.array(z.string()),
  dq_team_keys: z.array(z.string()),
});

export const zMatchSimple = z.object({
  key: z.string(),
  comp_level: zCompLevel,
  set_number: z.int(),
  match_number: z.int(),
  alliances: z.object({
    red: zMatchAlliance,
    blue: zMatchAlliance,
  }),
  winning_alliance: z.enum(['red', 'blue', '']),
  event_key: z.string(),
  time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
  predicted_time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
  actual_time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
});

/**
 * The `Media` object contains a reference for most any media associated with a team or event on TBA.
 */
export const zMedia = z.object({
  type: z.enum([
    'youtube',
    'cdphotothread',
    'imgur',
    'facebook-profile',
    'youtube-channel',
    'twitter-profile',
    'github-profile',
    'instagram-profile',
    'periscope-profile',
    'gitlab-profile',
    'grabcad',
    'instagram-image',
    'external-link',
    'avatar',
    'onshape',
    'cd-thread',
  ]),
  foreign_key: z.string(),
  details: z
    .union([
      z.record(z.string(), z.never()),
      z.object({
        base64Image: z.string(),
      }),
      z.object({
        author_id: z.int(),
        author_name: z.string(),
        author_url: z.url(),
        height: z.int().nullable(),
        html: z.string(),
        media_id: z.string(),
        provider_name: z.string(),
        provider_url: z.url(),
        thumbnail_height: z.int(),
        thumbnail_url: z.url(),
        thumbnail_width: z.int(),
        title: z.string(),
        type: z.string(),
        version: z.string(),
        width: z.int(),
      }),
      z.object({
        model_created: z.iso.datetime({ offset: true }),
        model_description: z.string().nullable(),
        model_image: z.url(),
        model_name: z.string(),
      }),
      z.object({
        image_partial: z.string(),
      }),
      z.object({
        thread_title: z.string(),
        image_url: z.string().nullable(),
      }),
    ])
    .optional(),
  preferred: z.boolean().optional(),
  team_keys: z.array(z.string()),
  direct_url: z.string().optional(),
  view_url: z.string().optional(),
});

export const zMobilityRobot2023 = z.enum(['No', 'Yes']);

export const zMatchScoreBreakdown2023Alliance = z.object({
  activationBonusAchieved: z.boolean().optional(),
  adjustPoints: z.int().optional(),
  autoBridgeState: zBridgeState2023.optional(),
  autoChargeStationPoints: z.int().optional(),
  autoChargeStationRobot1: zAutoChargeStationRobot2023.optional(),
  autoChargeStationRobot2: zAutoChargeStationRobot2023.optional(),
  autoChargeStationRobot3: zAutoChargeStationRobot2023.optional(),
  autoDocked: z.boolean().optional(),
  autoCommunity: z
    .object({
      B: z.array(z.enum(['None', 'Cone', 'Cube'])),
      M: z.array(z.enum(['None', 'Cone', 'Cube'])),
      T: z.array(z.enum(['None', 'Cone', 'Cube'])),
    })
    .optional(),
  autoGamePieceCount: z.int().optional(),
  autoGamePiecePoints: z.int().optional(),
  autoMobilityPoints: z.int(),
  mobilityRobot1: zMobilityRobot2023,
  mobilityRobot2: zMobilityRobot2023,
  mobilityRobot3: zMobilityRobot2023,
  autoPoints: z.int(),
  coopGamePieceCount: z.int().optional(),
  coopertitionCriteriaMet: z.boolean().optional(),
  endGameBridgeState: zBridgeState2023.optional(),
  endGameChargeStationPoints: z.int().optional(),
  endGameChargeStationRobot1: zEndGameChargeStationRobot2023.optional(),
  endGameChargeStationRobot2: zEndGameChargeStationRobot2023.optional(),
  endGameChargeStationRobot3: zEndGameChargeStationRobot2023.optional(),
  endGameParkPoints: z.int().optional(),
  extraGamePieceCount: z.int().optional(),
  foulCount: z.int(),
  foulPoints: z.int(),
  techFoulCount: z.int(),
  linkPoints: z.int().optional(),
  links: z
    .array(
      z.object({
        nodes: z.array(z.enum(['None', 'Cone', 'Cube'])),
        row: z.enum(['Bottom', 'Mid', 'Top']),
      }),
    )
    .nullish(),
  sustainabilityBonusAchieved: z.boolean().optional(),
  teleopCommunity: z
    .object({
      B: z.array(z.enum(['None', 'Cone', 'Cube'])),
      M: z.array(z.enum(['None', 'Cone', 'Cube'])),
      T: z.array(z.enum(['None', 'Cone', 'Cube'])),
    })
    .optional(),
  teleopGamePieceCount: z.int().optional(),
  teleopGamePiecePoints: z.int().optional(),
  totalChargeStationPoints: z.int().optional(),
  teleopPoints: z.int(),
  rp: z.int(),
  totalPoints: z.int(),
});

/**
 * See the 2023 FMS API documentation for a description of each value. https://frc-api-docs.firstinspires.org
 */
export const zMatchScoreBreakdown2023 = z.object({
  blue: zMatchScoreBreakdown2023Alliance,
  red: zMatchScoreBreakdown2023Alliance,
});

export const zNotablesInsight = z.object({
  data: z.object({
    entries: z.array(
      z.object({
        context: z.array(z.string()),
        team_key: z.string(),
      }),
    ),
  }),
  name: z.string(),
  year: z.int(),
});

export const zPosition2016 = z.enum([
  '',
  'A_ChevalDeFrise',
  'A_Portcullis',
  'B_Moat',
  'B_Ramparts',
  'C_Drawbridge',
  'C_SallyPort',
  'D_RockWall',
  'D_RoughTerrain',
  'NotSpecified',
]);

export const zPreMatchBay2019 = z.enum(['Cargo', 'Panel', 'Unknown']);

export const zMatchScoreBreakdown2019Alliance = z.object({
  adjustPoints: z.int().optional(),
  autoPoints: z.int().optional(),
  bay1: zBay2019,
  bay2: zBay2019,
  bay3: zBay2019,
  bay4: zBay2019,
  bay5: zBay2019,
  bay6: zBay2019,
  bay7: zBay2019,
  bay8: zBay2019,
  cargoPoints: z.int(),
  completeRocketRankingPoint: z.boolean(),
  completedRocketFar: z.boolean().optional(),
  completedRocketNear: z.boolean().optional(),
  endgameRobot1: zEndgameRobot2019,
  endgameRobot2: zEndgameRobot2019,
  endgameRobot3: zEndgameRobot2019,
  foulCount: z.int().optional(),
  foulPoints: z.int(),
  habClimbPoints: z.int(),
  habDockingRankingPoint: z.boolean(),
  habLineRobot1: zHabLine2019,
  habLineRobot2: zHabLine2019,
  habLineRobot3: zHabLine2019,
  hatchPanelPoints: z.int(),
  lowLeftRocketFar: zBay2019,
  lowLeftRocketNear: zBay2019,
  lowRightRocketFar: zBay2019,
  lowRightRocketNear: zBay2019,
  midLeftRocketFar: zBay2019,
  midLeftRocketNear: zBay2019,
  midRightRocketFar: zBay2019,
  midRightRocketNear: zBay2019,
  preMatchBay1: zPreMatchBay2019,
  preMatchBay2: zPreMatchBay2019,
  preMatchBay3: zPreMatchBay2019,
  preMatchBay6: zPreMatchBay2019,
  preMatchBay7: zPreMatchBay2019,
  preMatchBay8: zPreMatchBay2019,
  preMatchLevelRobot1: zEndgameRobot2019,
  preMatchLevelRobot2: zEndgameRobot2019,
  preMatchLevelRobot3: zEndgameRobot2019,
  rp: z.int(),
  sandStormBonusPoints: z.int(),
  techFoulCount: z.int().optional(),
  teleopPoints: z.int(),
  topLeftRocketFar: zBay2019,
  topLeftRocketNear: zBay2019,
  topRightRocketFar: zBay2019,
  topRightRocketNear: zBay2019,
  totalPoints: z.int(),
});

/**
 * See the 2019 FMS API documentation for a description of each value. https://frcevents2.docs.apiary.io/#/reference/match-results/score-details
 */
export const zMatchScoreBreakdown2019 = z.object({
  blue: zMatchScoreBreakdown2019Alliance,
  red: zMatchScoreBreakdown2019Alliance,
});

export const zReefRow2025 = z.object({
  nodeA: z.boolean(),
  nodeB: z.boolean(),
  nodeC: z.boolean(),
  nodeD: z.boolean(),
  nodeE: z.boolean(),
  nodeF: z.boolean(),
  nodeG: z.boolean(),
  nodeH: z.boolean(),
  nodeI: z.boolean(),
  nodeJ: z.boolean(),
  nodeK: z.boolean(),
  nodeL: z.boolean(),
});

export const zMatchScoreBreakdown2025Alliance = z.object({
  adjustPoints: z.int().optional(),
  algaePoints: z.int(),
  autoBonusAchieved: z.boolean().optional(),
  autoCoralCount: z.int(),
  autoCoralPoints: z.int(),
  autoLineRobot1: zAutoLineRobot2024,
  autoLineRobot2: zAutoLineRobot2024,
  autoLineRobot3: zAutoLineRobot2024,
  autoMobilityPoints: z.int(),
  autoPoints: z.int(),
  autoReef: z.object({
    topRow: zReefRow2025,
    midRow: zReefRow2025,
    botRow: zReefRow2025,
    trough: z.int(),
    tba_botRowCount: z.int().optional(),
    tba_midRowCount: z.int().optional(),
    tba_topRowCount: z.int().optional(),
  }),
  bargeBonusAchieved: z.boolean().optional(),
  coopertitionCriteriaMet: z.boolean().optional(),
  coralBonusAchieved: z.boolean().optional(),
  endGameBargePoints: z.int(),
  endGameRobot1: zEndGameRobot2025,
  endGameRobot2: zEndGameRobot2025,
  endGameRobot3: zEndGameRobot2025,
  foulCount: z.int(),
  foulPoints: z.int(),
  g206Penalty: z.boolean(),
  g410Penalty: z.boolean(),
  g418Penalty: z.boolean(),
  g428Penalty: z.boolean(),
  netAlgaeCount: z.int(),
  rp: z.int(),
  techFoulCount: z.int(),
  teleopCoralCount: z.int(),
  teleopCoralPoints: z.int(),
  teleopPoints: z.int(),
  teleopReef: z.object({
    topRow: zReefRow2025,
    midRow: zReefRow2025,
    botRow: zReefRow2025,
    trough: z.int(),
    tba_botRowCount: z.int().optional(),
    tba_midRowCount: z.int().optional(),
    tba_topRowCount: z.int().optional(),
  }),
  totalPoints: z.int(),
  wallAlgaeCount: z.int(),
});

/**
 * See the 2025 FMS API documentation for a description of each value. https://frc-api-docs.firstinspires.org
 */
export const zMatchScoreBreakdown2025 = z.object({
  blue: zMatchScoreBreakdown2025Alliance,
  red: zMatchScoreBreakdown2025Alliance,
});

/**
 * Information about how a regional team qualified for FIRST Championship.
 */
export const zRegionalAdvancement = z.object({
  cmp: z.boolean(),
  cmp_status: z.enum([
    'NotInvited',
    'PreQualified',
    'EventQualified',
    'PoolQualified',
    'Declined',
  ]),
  qualifying_event: z.string().optional(),
  qualifying_award_name: z.string().optional(),
  qualifying_pool_week: z.int().optional(),
});

/**
 * Rank of a team in the regional pool.
 */
export const zRegionalRanking = z.object({
  team_key: z.string(),
  rank: z.int(),
  rookie_bonus: z.int().optional(),
  single_event_bonus: z.int().optional(),
  point_total: z.int(),
  event_points: z
    .array(
      z.object({
        total: z.int(),
        alliance_points: z.int(),
        elim_points: z.int(),
        award_points: z.int(),
        event_key: z.string(),
        qual_points: z.int(),
      }),
    )
    .optional(),
});

export const zRobotAuto2016WithUnknown = z.enum([
  'Crossed',
  'None',
  'Reached',
  'Unknown',
]);

export const zRobotAuto2016WithoutUnknown = z.enum([
  'Crossed',
  'Reached',
  'None',
]);

export const zRobotAuto2017 = z.enum(['Mobility', 'None', 'Unknown']);

export const zSearchIndex = z.object({
  teams: z.array(
    z.object({
      key: z.string(),
      nickname: z.string(),
    }),
  ),
  events: z.array(
    z.object({
      key: z.string(),
      name: z.string(),
    }),
  ),
});

export const zStage3TargetColor2020 = z.enum([
  'Blue',
  'Green',
  'Red',
  'Unknown',
  'Yellow',
]);

export const zMatchScoreBreakdown2020Alliance = z.object({
  initLineRobot1: zInitLineRobot2020,
  endgameRobot1: zEndgameRobot2020,
  initLineRobot2: zInitLineRobot2020,
  endgameRobot2: zEndgameRobot2020,
  initLineRobot3: zInitLineRobot2020,
  endgameRobot3: zEndgameRobot2020,
  autoCellsBottom: z.int(),
  autoCellsOuter: z.int(),
  autoCellsInner: z.int(),
  teleopCellsBottom: z.int(),
  teleopCellsOuter: z.int(),
  teleopCellsInner: z.int(),
  stage1Activated: z.boolean(),
  stage2Activated: z.boolean(),
  stage3Activated: z.boolean(),
  stage3TargetColor: zStage3TargetColor2020,
  endgameRungIsLevel: zEndgameRungIsLevel2020,
  autoInitLinePoints: z.int(),
  autoCellPoints: z.int(),
  autoPoints: z.int(),
  teleopCellPoints: z.int(),
  controlPanelPoints: z.int(),
  endgamePoints: z.int(),
  teleopPoints: z.int(),
  shieldOperationalRankingPoint: z.boolean(),
  shieldEnergizedRankingPoint: z.boolean(),
  tba_shieldEnergizedRankingPointFromFoul: z.boolean().optional(),
  tba_numRobotsHanging: z.int().optional(),
  foulCount: z.int(),
  techFoulCount: z.int(),
  adjustPoints: z.int().optional(),
  foulPoints: z.int(),
  rp: z.int().optional(),
  totalPoints: z.int(),
});

/**
 * See the 2020 FMS API documentation for a description of each value. https://frcevents2.docs.apiary.io/#/reference/match-results/score-details
 */
export const zMatchScoreBreakdown2020 = z.object({
  blue: zMatchScoreBreakdown2020Alliance,
  red: zMatchScoreBreakdown2020Alliance,
});

export const zTaxiRobot2022 = z.enum(['No', 'Yes']);

export const zMatchScoreBreakdown2022Alliance = z.object({
  taxiRobot1: zTaxiRobot2022.optional(),
  endgameRobot1: zEndgameRobot2022.optional(),
  taxiRobot2: zTaxiRobot2022.optional(),
  endgameRobot2: zEndgameRobot2022.optional(),
  taxiRobot3: zTaxiRobot2022.optional(),
  endgameRobot3: zEndgameRobot2022.optional(),
  autoCargoLowerNear: z.int().optional(),
  autoCargoLowerFar: z.int().optional(),
  autoCargoLowerBlue: z.int().optional(),
  autoCargoLowerRed: z.int().optional(),
  autoCargoUpperNear: z.int().optional(),
  autoCargoUpperFar: z.int().optional(),
  autoCargoUpperBlue: z.int().optional(),
  autoCargoUpperRed: z.int().optional(),
  autoCargoTotal: z.int().optional(),
  teleopCargoLowerNear: z.int().optional(),
  teleopCargoLowerFar: z.int().optional(),
  teleopCargoLowerBlue: z.int().optional(),
  teleopCargoLowerRed: z.int().optional(),
  teleopCargoUpperNear: z.int().optional(),
  teleopCargoUpperFar: z.int().optional(),
  teleopCargoUpperBlue: z.int().optional(),
  teleopCargoUpperRed: z.int().optional(),
  teleopCargoTotal: z.int().optional(),
  matchCargoTotal: z.int().optional(),
  autoTaxiPoints: z.int().optional(),
  autoCargoPoints: z.int().optional(),
  autoPoints: z.int().optional(),
  quintetAchieved: z.boolean().optional(),
  teleopCargoPoints: z.int().optional(),
  endgamePoints: z.int().optional(),
  teleopPoints: z.int().optional(),
  cargoBonusRankingPoint: z.boolean().optional(),
  hangarBonusRankingPoint: z.boolean().optional(),
  foulCount: z.int().optional(),
  techFoulCount: z.int().optional(),
  adjustPoints: z.int().optional(),
  foulPoints: z.int().optional(),
  rp: z.int().nullish(),
  totalPoints: z.int().optional(),
});

/**
 * See the 2022 FMS API documentation for a description of each value. https://frc-api-docs.firstinspires.org
 */
export const zMatchScoreBreakdown2022 = z.object({
  blue: zMatchScoreBreakdown2022Alliance,
  red: zMatchScoreBreakdown2022Alliance,
});

export const zTeam = z.object({
  key: z.string(),
  team_number: z.int(),
  nickname: z.string(),
  name: z.string(),
  school_name: z.string().nullable(),
  city: z.string().nullable(),
  state_prov: z.string().nullable(),
  country: z.string().nullable(),
  address: z.string().nullable(),
  postal_code: z.string().nullable(),
  gmaps_place_id: z.string().nullable(),
  gmaps_url: z.string().nullable(),
  lat: z.number().nullable(),
  lng: z.number().nullable(),
  location_name: z.string().nullable(),
  website: z.string().nullable(),
  rookie_year: z.int().nullable(),
  motto: z.string().nullable(),
});

/**
 * Backup status, may be null.
 */
export const zTeamEventStatusAllianceBackup = z
  .object({
    out: z.string().optional(),
    in: z.string().optional(),
  })
  .nullable();

export const zTeamEventStatusAlliance = z.object({
  name: z.string().nullish(),
  number: z.int(),
  backup: zTeamEventStatusAllianceBackup.optional(),
  pick: z.int(),
});

export const zTeamRobot = z.object({
  year: z.int(),
  robot_name: z.string(),
  key: z.string(),
  team_key: z.string(),
});

export const zTeamSimple = z.object({
  key: z.string(),
  team_number: z.int(),
  nickname: z.string(),
  name: z.string(),
  city: z.string().nullable(),
  state_prov: z.string().nullable(),
  country: z.string().nullable(),
});

export const zTouchpad2017 = z.enum(['None', 'ReadyForTakeoff']);

export const zMatchScoreBreakdown2017Alliance = z.object({
  autoPoints: z.int(),
  teleopPoints: z.int(),
  foulPoints: z.int(),
  adjustPoints: z.int().optional(),
  totalPoints: z.int(),
  robot1Auto: zRobotAuto2017.optional(),
  robot2Auto: zRobotAuto2017.optional(),
  robot3Auto: zRobotAuto2017.optional(),
  rotor1Auto: z.boolean(),
  rotor2Auto: z.boolean(),
  autoFuelLow: z.int(),
  autoFuelHigh: z.int(),
  autoMobilityPoints: z.int(),
  autoRotorPoints: z.int(),
  autoFuelPoints: z.int(),
  teleopFuelPoints: z.int(),
  teleopFuelLow: z.int(),
  teleopFuelHigh: z.int(),
  teleopRotorPoints: z.int(),
  kPaRankingPointAchieved: z.boolean(),
  teleopTakeoffPoints: z.int(),
  kPaBonusPoints: z.int(),
  rotorBonusPoints: z.int(),
  rotor1Engaged: z.boolean(),
  rotor2Engaged: z.boolean(),
  rotor3Engaged: z.boolean(),
  rotor4Engaged: z.boolean(),
  rotorRankingPointAchieved: z.boolean(),
  tba_rpEarned: z.int().nullish(),
  techFoulCount: z.int().optional(),
  foulCount: z.int().optional(),
  touchpadNear: zTouchpad2017.optional(),
  touchpadMiddle: zTouchpad2017.optional(),
  touchpadFar: zTouchpad2017.optional(),
});

/**
 * See the 2017 FMS API documentation for a description of each value.
 */
export const zMatchScoreBreakdown2017 = z.object({
  blue: zMatchScoreBreakdown2017Alliance,
  red: zMatchScoreBreakdown2017Alliance,
});

export const zTowerFace2016 = z.enum([
  'Both',
  'Challenged',
  'None',
  'Scaled',
  'Unknown',
]);

export const zMatchScoreBreakdown2016Alliance = z.object({
  autoPoints: z.int(),
  teleopPoints: z.int().optional(),
  breachPoints: z.int(),
  foulPoints: z.int(),
  capturePoints: z.int(),
  adjustPoints: z.int().optional(),
  totalPoints: z.int(),
  tba_rpEarned: z.int().nullable(),
  robot1Auto: zRobotAuto2016WithUnknown.optional(),
  robot2Auto: zRobotAuto2016WithoutUnknown.optional(),
  robot3Auto: zRobotAuto2016WithUnknown.optional(),
  autoReachPoints: z.int(),
  autoCrossingPoints: z.int(),
  autoBouldersLow: z.int().optional(),
  autoBouldersHigh: z.int().optional(),
  autoBoulderPoints: z.int(),
  teleopCrossingPoints: z.int(),
  teleopBouldersLow: z.int(),
  teleopBouldersHigh: z.int(),
  teleopBoulderPoints: z.int(),
  teleopDefensesBreached: z.boolean(),
  teleopChallengePoints: z.int(),
  teleopScalePoints: z.int(),
  teleopTowerCaptured: z.boolean(),
  towerFaceA: zTowerFace2016.optional(),
  towerFaceB: zTowerFace2016.optional(),
  towerFaceC: zTowerFace2016.optional(),
  towerEndStrength: z.int().optional(),
  techFoulCount: z.int().optional(),
  foulCount: z.int().optional(),
  position2: zPosition2016,
  position3: zPosition2016,
  position4: zPosition2016,
  position5: zPosition2016,
  position1crossings: z.int(),
  position2crossings: z.int(),
  position3crossings: z.int(),
  position4crossings: z.int(),
  position5crossings: z.int(),
});

/**
 * See the 2016 FMS API documentation for a description of each value.
 */
export const zMatchScoreBreakdown2016 = z.object({
  blue: zMatchScoreBreakdown2016Alliance,
  red: zMatchScoreBreakdown2016Alliance,
});

export const zMatch = z.object({
  key: z.string(),
  comp_level: zCompLevel,
  set_number: z.int(),
  match_number: z.int(),
  alliances: z.object({
    red: zMatchAlliance,
    blue: zMatchAlliance,
  }),
  winning_alliance: z.enum(['red', 'blue', '']),
  event_key: z.string(),
  time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
  actual_time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
  predicted_time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
  post_result_time: z.coerce
    .bigint()
    .min(BigInt('-9223372036854775808'), {
      error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
    })
    .max(BigInt('9223372036854775807'), {
      error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
    })
    .nullable(),
  score_breakdown: z
    .union([
      zMatchScoreBreakdown2015,
      zMatchScoreBreakdown2016,
      zMatchScoreBreakdown2017,
      zMatchScoreBreakdown2018,
      zMatchScoreBreakdown2019,
      zMatchScoreBreakdown2020,
      zMatchScoreBreakdown2022,
      zMatchScoreBreakdown2023,
      zMatchScoreBreakdown2024,
      zMatchScoreBreakdown2025,
      zMatchScoreBreakdown2026,
    ])
    .nullable(),
  videos: z.array(
    z.object({
      type: z.string(),
      key: z.string(),
    }),
  ),
});

/**
 * A Win-Loss-Tie record for a team, or an alliance.
 */
export const zWltRecord = z.object({
  losses: z.int(),
  wins: z.int(),
  ties: z.int(),
});

export const zDistrictInsight = z.object({
  district_data: z.object({
    region_data: z.record(z.string(), zDistrictInsightRegionData).nullable(),
    district_wide_data: zDistrictInsightRegionData.nullable(),
  }),
  team_data: z
    .record(
      z.string(),
      z.object({
        district_seasons: z.int(),
        total_district_points: z.int(),
        total_pre_dcmp_district_points: z.int(),
        district_event_wins: z.int(),
        dcmp_wins: z.int(),
        team_awards: z.int(),
        individual_awards: z.int(),
        quals_record: zWltRecord,
        elims_record: zWltRecord,
        in_district_extra_play_count: z.int(),
        total_matches_played: z.int(),
        dcmp_appearances: z.int(),
        cmp_appearances: z.int(),
      }),
    )
    .nullable(),
});

export const zEliminationAlliance = z.object({
  name: z.string().optional(),
  backup: z
    .object({
      in: z.string(),
      out: z.string(),
    })
    .nullish(),
  declines: z.array(z.string()),
  picks: z.array(z.string()),
  status: z
    .object({
      playoff_average: z.number().nullish(),
      playoff_type: z.coerce
        .bigint()
        .min(BigInt('-9223372036854775808'), {
          error: 'Invalid value: Expected int64 to be >= -9223372036854775808',
        })
        .max(BigInt('9223372036854775807'), {
          error: 'Invalid value: Expected int64 to be <= 9223372036854775807',
        })
        .nullable(),
      level: zCompLevel,
      record: zWltRecord.nullable(),
      current_level_record: zWltRecord.nullable(),
      status: z.enum(['eliminated', 'playing', 'won']),
      advanced_to_round_robin_finals: z.boolean().optional(),
      double_elim_round: zDoubleElimRound.optional(),
      round_robin_rank: z.int().optional(),
    })
    .optional(),
});

export const zEventRanking = z.object({
  rankings: z.array(
    z.object({
      matches_played: z.int(),
      qual_average: z.int().nullable(),
      extra_stats: z.array(z.number()),
      sort_orders: z.array(z.number()),
      record: zWltRecord.nullable(),
      rank: z.int(),
      dq: z.int(),
      team_key: z.string(),
    }),
  ),
  extra_stats_info: z.array(
    z.object({
      precision: z.number(),
      name: z.string(),
    }),
  ),
  sort_order_info: z
    .array(
      z.object({
        precision: z.int(),
        name: z.string(),
      }),
    )
    .nullable(),
});

/**
 * Playoff status for this team, may be null if the team did not make playoffs, or playoffs have not begun.
 */
export const zTeamEventStatusPlayoff = z
  .object({
    level: zCompLevel.optional(),
    current_level_record: zWltRecord.nullish(),
    record: zWltRecord.nullish(),
    status: z.enum(['won', 'eliminated', 'playing']).optional(),
    playoff_average: z.number().nullish(),
  })
  .nullable();

export const zTeamEventStatusRank = z.object({
  num_teams: z.int().optional(),
  ranking: z
    .object({
      matches_played: z.int().optional(),
      qual_average: z.number().nullish(),
      sort_orders: z.array(z.number()).nullish(),
      record: zWltRecord.nullish(),
      rank: z.int().nullish(),
      dq: z.int().nullish(),
      team_key: z.string().optional(),
    })
    .nullish(),
  sort_order_info: z
    .array(
      z.object({
        precision: z.int().optional(),
        name: z.string().optional(),
      }),
    )
    .nullish(),
  status: z.string().optional(),
});

export const zTeamEventStatus = z.object({
  qual: zTeamEventStatusRank.nullish(),
  alliance: zTeamEventStatusAlliance.nullish(),
  playoff: zTeamEventStatusPlayoff.nullish(),
  alliance_status_str: z.string().optional(),
  playoff_status_str: z.string().optional(),
  overall_status_str: z.string().optional(),
  next_match_key: z.string().nullish(),
  last_match_key: z.string().nullish(),
});

export const zWebcast = z.object({
  type: z.enum([
    'youtube',
    'twitch',
    'ustream',
    'iframe',
    'html5',
    'rtmp',
    'livestream',
    'direct_link',
    'mms',
    'justin',
    'stemtv',
    'dacast',
  ]),
  channel: z.string(),
  date: z.string().nullish(),
  file: z.string().nullish(),
  status: z.enum(['unknown', 'online', 'offline']).optional(),
  stream_title: z.string().nullish(),
  viewer_count: z.int().nullish(),
});

export const zEvent = z.object({
  key: z.string(),
  name: z.string(),
  event_code: z.string(),
  event_type: z.int(),
  district: zDistrict.nullable(),
  city: z.string().nullable(),
  state_prov: z.string().nullable(),
  country: z.string().nullable(),
  start_date: z.iso.date(),
  end_date: z.iso.date(),
  year: z.int(),
  short_name: z.string().nullable(),
  event_type_string: z.string(),
  week: z.int().nullable(),
  address: z.string().nullable(),
  postal_code: z.string().nullable(),
  gmaps_place_id: z.string().nullable(),
  gmaps_url: z.string().nullable(),
  lat: z.number().nullable(),
  lng: z.number().nullable(),
  location_name: z.string().nullable(),
  timezone: z.string().nullable(),
  website: z.string().nullable(),
  first_event_id: z.string().nullable(),
  first_event_code: z.string().nullable(),
  webcasts: z.array(zWebcast),
  division_keys: z.array(z.string()),
  parent_event_key: z.string().nullable(),
  playoff_type: z.int().nullable(),
  playoff_type_string: z.string().nullable(),
  remap_teams: z.record(z.string(), z.string()).nullable(),
});

export const zHistory = z.object({
  events: z.array(zEvent),
  awards: z.array(zAward),
});

export const zZebraTeam = z.object({
  team_key: z.string(),
  xs: z.array(z.number()),
  ys: z.array(z.number()),
});

export const zZebra = z.object({
  key: z.string(),
  times: z.array(z.number()),
  alliances: z.object({
    red: z.array(zZebraTeam).optional(),
    blue: z.array(zZebraTeam).optional(),
  }),
});

/**
 * Value of the `ETag` header in the most recently cached response by the client.
 */
export const zIfNoneMatch = z.string();

/**
 * District abbreviation, eg `ne` or `fim`
 */
export const zDistrictAbbreviation = z.string();

/**
 * TBA District Key, eg `2016fim`
 */
export const zDistrictKey = z.string();

/**
 * TBA Event Key, eg `2016nytr`
 */
export const zEventKey = z.string();

/**
 * TBA Match Key, eg `2016nytr_qm1`
 */
export const zMatchKey = z.string();

/**
 * Media Tag which describes the Media.
 */
export const zMediaTag = z.string();

/**
 * Page number of results to return, zero-indexed
 */
export const zPageNum = z.int();

/**
 * TBA Team Key, eg `frc254`
 */
export const zTeamKey = z.string();

/**
 * Competition Year (or Season). Must be 4 digits.
 */
export const zYear = z.int();

export const zGetDistrictDcmpHistoryData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_abbreviation: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictDcmpHistoryResponse = z.array(
  z.object({
    awards: z.array(zAward).optional(),
    event: zEvent.optional(),
  }),
);

export const zGetDistrictHistoryData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_abbreviation: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictHistoryResponse = z.array(zDistrict);

export const zGetDistrictInsightsData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_abbreviation: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictInsightsResponse = zDistrictInsight;

export const zGetDistrictAdvancementData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * A mapping of team key to District_Advancement
 */
export const zGetDistrictAdvancementResponse = z
  .record(z.string(), zDistrictAdvancement)
  .nullable();

export const zGetDistrictAwardsData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictAwardsResponse = z.array(zAward);

export const zGetDistrictEventsData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictEventsResponse = z.array(zEvent);

export const zGetDistrictEventsKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Event Keys
 */
export const zGetDistrictEventsKeysResponse = z.array(z.string());

export const zGetDistrictEventsSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictEventsSimpleResponse = z.array(zEventSimple);

export const zGetDistrictRankingsData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictRankingsResponse = z
  .array(zDistrictRanking)
  .nullable();

export const zGetDistrictTeamsData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictTeamsResponse = z.array(zTeam);

export const zGetDistrictTeamsKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Team Keys
 */
export const zGetDistrictTeamsKeysResponse = z.array(z.string());

export const zGetDistrictTeamsSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    district_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictTeamsSimpleResponse = z.array(zTeamSimple);

export const zGetDistrictsByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetDistrictsByYearResponse = z.array(zDistrict);

export const zGetEventData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventResponse = zEvent;

export const zGetEventAdvancementPointsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventAdvancementPointsResponse =
  zEventDistrictPoints.nullable();

export const zGetEventAlliancesData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventAlliancesResponse = z
  .array(zEliminationAlliance)
  .nullable();

export const zGetEventAwardsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventAwardsResponse = z.array(zAward);

export const zGetEventCoprsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventCoprsResponse = zEventCoprs.nullable();

export const zGetEventDistrictPointsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventDistrictPointsResponse = zEventDistrictPoints.nullable();

export const zGetEventInsightsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventInsightsResponse = zEventInsights.nullable();

export const zGetEventMatchesData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventMatchesResponse = z.array(zMatch);

export const zGetEventMatchesKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Match Keys
 */
export const zGetEventMatchesKeysResponse = z.array(z.string());

export const zGetEventMatchesSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventMatchesSimpleResponse = z.array(zMatchSimple);

export const zGetEventMatchTimeseriesData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventMatchTimeseriesResponse = z.array(z.string());

export const zGetEventOprsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventOprsResponse = zEventOprs.nullable();

export const zGetEventPredictionsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventPredictionsResponse = zEventPredictions.nullable();

export const zGetEventRankingsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventRankingsResponse = zEventRanking.nullable();

export const zGetRegionalChampsPoolPointsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetRegionalChampsPoolPointsResponse =
  zEventDistrictPoints.nullable();

export const zGetEventSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventSimpleResponse = zEventSimple;

export const zGetEventTeamMediaData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventTeamMediaResponse = z.array(zMedia);

export const zGetEventTeamsData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventTeamsResponse = z.array(zTeam);

export const zGetEventTeamsKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Team Keys
 */
export const zGetEventTeamsKeysResponse = z.array(z.string());

export const zGetEventTeamsSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventTeamsSimpleResponse = z.array(zTeamSimple);

export const zGetEventTeamsStatusesData = z.object({
  body: z.never().optional(),
  path: z.object({
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * A key-value pair of `Team_Event_Status` objects with the event key as the key.
 */
export const zGetEventTeamsStatusesResponse = z.record(
  z.string(),
  zTeamEventStatus,
);

export const zGetEventsByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventsByYearResponse = z.array(zEvent);

export const zGetEventsByYearKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Event Keys
 */
export const zGetEventsByYearKeysResponse = z.array(z.string());

export const zGetEventsByYearSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetEventsByYearSimpleResponse = z.array(zEventSimple);

export const zGetInsightsLeaderboardsYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetInsightsLeaderboardsYearResponse =
  z.array(zLeaderboardInsight);

export const zGetInsightsNotablesYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetInsightsNotablesYearResponse = z.array(zNotablesInsight);

export const zGetMatchData = z.object({
  body: z.never().optional(),
  path: z.object({
    match_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetMatchResponse = zMatch;

export const zGetMatchSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    match_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetMatchSimpleResponse = zMatchSimple;

export const zGetMatchTimeseriesData = z.object({
  body: z.never().optional(),
  path: z.object({
    match_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetMatchTimeseriesResponse = z.array(
  z.record(z.string(), z.unknown()),
);

export const zGetMatchZebraData = z.object({
  body: z.never().optional(),
  path: z.object({
    match_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetMatchZebraResponse = zZebra;

export const zGetRegionalAdvancementData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetRegionalAdvancementResponse = z
  .record(z.string(), zRegionalAdvancement)
  .nullable();

export const zGetRegionalRankingsData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetRegionalRankingsResponse = z
  .array(zRegionalRanking)
  .nullable();

export const zGetSearchIndexData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetSearchIndexResponse = zSearchIndex;

export const zGetStatusData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetStatusResponse = zApiStatus;

export const zGetTeamData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamResponse = zTeam;

export const zGetTeamAwardsData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamAwardsResponse = z.array(zAward);

export const zGetTeamAwardsByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamAwardsByYearResponse = z.array(zAward);

export const zGetTeamDistrictsData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamDistrictsResponse = z.array(zDistrict);

export const zGetTeamEventAwardsData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventAwardsResponse = z.array(zAward);

export const zGetTeamEventMatchesData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventMatchesResponse = z.array(zMatch);

export const zGetTeamEventMatchesKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Match Keys
 */
export const zGetTeamEventMatchesKeysResponse = z.array(z.string());

export const zGetTeamEventMatchesSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventMatchesSimpleResponse = z.array(zMatch);

export const zGetTeamEventStatusData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    event_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventStatusResponse = zTeamEventStatus.nullable();

export const zGetTeamEventsData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventsResponse = z.array(zEvent);

export const zGetTeamEventsKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Event Keys
 */
export const zGetTeamEventsKeysResponse = z.array(z.string());

export const zGetTeamEventsSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventsSimpleResponse = z.array(zEventSimple);

export const zGetTeamEventsByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventsByYearResponse = z.array(zEvent);

export const zGetTeamEventsByYearKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Event Keys
 */
export const zGetTeamEventsByYearKeysResponse = z.array(z.string());

export const zGetTeamEventsByYearSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamEventsByYearSimpleResponse = z.array(zEventSimple);

export const zGetTeamEventsStatusesByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * A key-value pair of `Team_Event_Status` objects with the event key as the key.
 */
export const zGetTeamEventsStatusesByYearResponse = z.record(
  z.string(),
  zTeamEventStatus,
);

export const zGetTeamHistoryData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response with team's history including events and awards.
 */
export const zGetTeamHistoryResponse = zHistory;

export const zGetTeamMatchesByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamMatchesByYearResponse = z.array(zMatch);

export const zGetTeamMatchesByYearKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Match Keys
 */
export const zGetTeamMatchesByYearKeysResponse = z.array(z.string());

export const zGetTeamMatchesByYearSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamMatchesByYearSimpleResponse = z.array(zMatchSimple);

export const zGetTeamMediaByTagData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    media_tag: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamMediaByTagResponse = z.array(zMedia);

export const zGetTeamMediaByTagYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    media_tag: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamMediaByTagYearResponse = z.array(zMedia);

export const zGetTeamMediaByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
    year: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamMediaByYearResponse = z.array(zMedia);

export const zGetTeamRobotsData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamRobotsResponse = z.array(zTeamRobot);

export const zGetTeamSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamSimpleResponse = zTeamSimple;

export const zGetTeamSocialMediaData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamSocialMediaResponse = z.array(zMedia);

export const zGetTeamYearsParticipatedData = z.object({
  body: z.never().optional(),
  path: z.object({
    team_key: z.string(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamYearsParticipatedResponse = z.array(z.int());

export const zGetTeamsData = z.object({
  body: z.never().optional(),
  path: z.object({
    page_num: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamsResponse = z.array(zTeam);

export const zGetTeamsKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    page_num: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamsKeysResponse = z.array(z.string());

export const zGetTeamsSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    page_num: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamsSimpleResponse = z.array(zTeamSimple);

export const zGetTeamsByYearData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
    page_num: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamsByYearResponse = z.array(zTeam);

export const zGetTeamsByYearKeysData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
    page_num: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Array of Team Keys
 */
export const zGetTeamsByYearKeysResponse = z.array(z.string());

export const zGetTeamsByYearSimpleData = z.object({
  body: z.never().optional(),
  path: z.object({
    year: z.int(),
    page_num: z.int(),
  }),
  query: z.never().optional(),
  headers: z
    .object({
      'If-None-Match': z.string().optional(),
    })
    .optional(),
});

/**
 * Successful response
 */
export const zGetTeamsByYearSimpleResponse = z.array(zTeamSimple);
